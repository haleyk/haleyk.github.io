<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AX-CPT (AX Continuous Performance Task)</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        
        .container {
            background-color: white;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            text-align: center;
            max-width: 800px;
            width: 100%;
        }
        
        .stimulus-area {
            width: 400px;
            height: 300px;
            border: 3px solid #ddd;
            margin: 20px auto;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 120px;
            font-weight: bold;
            background-color: #fafafa;
            position: relative;
        }
        
        .fixation {
            color: #666;
        }
        
        .cue {
            color: #2196F3;
        }
        
        .probe {
            color: #F44336;
        }
        
        .instructions {
            margin: 20px 0;
            padding: 20px;
            background-color: #e8f4f8;
            border-radius: 5px;
        }
        
        .key-instructions {
            margin: 20px 0;
            padding: 20px;
            background-color: #fff3cd;
            border-radius: 5px;
            font-size: 18px;
        }
        
        .controls {
            margin: 20px 0;
        }
        
        button {
            background-color: #4CAF50;
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 18px;
            margin: 10px;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        
        .stats {
            margin-top: 30px;
            padding: 20px;
            background-color: #f9f9f9;
            border-radius: 5px;
            text-align: left;
        }
        
        .progress {
            margin: 10px 0;
            font-weight: bold;
            font-size: 18px;
        }
        
        .phase-indicator {
            font-size: 16px;
            color: #666;
            margin: 10px 0;
            min-height: 20px;
        }
        
        .feedback {
            font-size: 18px;
            font-weight: bold;
            margin: 10px 0;
            min-height: 25px;
        }
        
        .correct { color: #4CAF50; }
        .incorrect { color: #F44336; }
        .no-response { color: #FF9800; }
        
        .key-reminder {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: rgba(0,0,0,0.8);
            color: white;
            padding: 15px;
            border-radius: 5px;
            font-size: 14px;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Letter Recognition Task</h1>
        
        <div class="instructions">
            <h3>Instructions:</h3>
            <p><strong>Only respond "TARGET" if you see the letter A followed by the letter X.</strong></p>
            <p><strong>For all other combinations (like B→X, A→Y, B→Y), respond "NON-TARGET".</strong></p>
            <p>You'll see letters one at a time. Remember the first letter, then respond when you see the second letter.</p>
        </div>
        
        <div class="key-instructions">
            <strong>Controls:</strong><br>
            Press <strong>J</strong> for TARGET (A→X only)<br>
            Press <strong>F</strong> for NON-TARGET (everything else)
        </div>
        
        <div class="stimulus-area" id="stimulusArea">
            <div id="stimulus">Ready</div>
        </div>
        
        <div class="phase-indicator" id="phaseIndicator"></div>
        <div class="feedback" id="feedback"></div>
        <div class="progress" id="progress">Ready to start</div>
        
        <div class="controls">
            <button onclick="startTask()" id="startBtn">Start Task</button>
            <button onclick="exportData()" id="exportBtn" disabled>Export Data</button>
        </div>
        
        <div class="stats" id="stats" style="display: none;">
            <h3>Results:</h3>
            <div id="statsContent"></div>
        </div>
    </div>

    <div class="key-reminder" id="keyReminder">
        <strong>Controls:</strong><br>
        J = TARGET (A→X)<br>
        F = NON-TARGET (other)
    </div>

    <script>
        // Task parameters
        const TOTAL_TRIALS = 40;
        const AX_PROBABILITY = 0.70; // 70% AX trials
        const AY_PROBABILITY = 0.10; // 10% AY trials  
        const BX_PROBABILITY = 0.10; // 10% BX trials
        const BY_PROBABILITY = 0.10; // 10% BY trials
        
        const FIXATION_TIME = 300;
        const CUE_TIME = 300;
        const DELAY_TIME = 1000;
        const PROBE_TIME = 300;
        const ITI_TIME = 500;
        const RESPONSE_TIMEOUT = 2000;
        const FEEDBACK_TIME = 300;
        
        // Possible letters (excluding A and X)
        // const OTHER_LETTERS = ['B', 'C', 'D', 'F', 'G', 'H', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'Y', 'Z'];
        const OTHER_LETTERS = ['B','Y']

        // Task variables
        let currentTrial = 0;
        let taskRunning = false;
        let trialData = [];
        let currentCue = '';
        let currentProbe = '';
        let currentTrialType = '';
        let trialStartTime = 0;
        let responseAllowed = false;
        let trialTimeout = null;
        let currentPhase = '';
        
        // Generate trial sequence
        let trialSequence = [];
        
        // DOM elements
        const stimulus = document.getElementById('stimulus');
        const stimulusArea = document.getElementById('stimulusArea');
        const phaseIndicator = document.getElementById('phaseIndicator');
        const feedback = document.getElementById('feedback');
        const progress = document.getElementById('progress');
        const keyReminder = document.getElementById('keyReminder');
        const startBtn = document.getElementById('startBtn');
        const exportBtn = document.getElementById('exportBtn');
        const stats = document.getElementById('stats');
        const statsContent = document.getElementById('statsContent');
        
        // Function to generate variable timing with normal distribution
        function getVariableTiming(mean = 1000, min = 300, max = 1700) {
            // Calculate standard deviation to fit most values in range
            const std = (max - min) / 6; // ~99.7% of values within range
            
            // Box-Muller transform for normal distribution
            let u = 0, v = 0;
            while(u === 0) u = Math.random(); // Converting [0,1) to (0,1)
            while(v === 0) v = Math.random();
            const z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
            
            // Convert to desired mean and std, then clamp to range
            const value = mean + z * std;
            return Math.max(min, Math.min(max, Math.round(value)));
        }
        
        function generateTrialSequence() {
            trialSequence = [];
            
            // Calculate number of each trial type
            const numAX = Math.round(TOTAL_TRIALS * AX_PROBABILITY);
            const numAY = Math.round(TOTAL_TRIALS * AY_PROBABILITY);
            const numBX = Math.round(TOTAL_TRIALS * BX_PROBABILITY);
            const numBY = TOTAL_TRIALS - numAX - numAY - numBX;
            
            // Create trials
            for (let i = 0; i < numAX; i++) trialSequence.push('AX');
            for (let i = 0; i < numAY; i++) trialSequence.push('AY');
            for (let i = 0; i < numBX; i++) trialSequence.push('BX');
            for (let i = 0; i < numBY; i++) trialSequence.push('BY');
            
            // Shuffle the sequence
            for (let i = trialSequence.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [trialSequence[i], trialSequence[j]] = [trialSequence[j], trialSequence[i]];
            }
        }
        
        function startTask() {
            currentTrial = 0;
            trialData = [];
            taskRunning = true;
            startBtn.disabled = true;
            exportBtn.disabled = true;
            stats.style.display = 'none';
            keyReminder.style.display = 'block';
            
            generateTrialSequence();
            runTrial();
        }
        
        function runTrial() {
            if (currentTrial >= TOTAL_TRIALS) {
                endTask();
                return;
            }
            
            currentTrial++;
            progress.textContent = `Trial ${currentTrial} of ${TOTAL_TRIALS}`;
            
            // Get trial type and generate stimuli
            currentTrialType = trialSequence[currentTrial - 1];
            generateStimuli(currentTrialType);
            
            responseAllowed = false;
            feedback.textContent = '';
            feedback.className = 'feedback';
            
            // Start trial sequence
            showFixation();
        }
        
        function generateStimuli(trialType) {
            switch(trialType) {
                case 'AX':
                    currentCue = 'A';
                    currentProbe = 'X';
                    break;
                case 'AY':
                    currentCue = 'A';
                    currentProbe = OTHER_LETTERS[Math.floor(Math.random() * OTHER_LETTERS.length)];
                    break;
                case 'BX':
                    currentCue = OTHER_LETTERS[Math.floor(Math.random() * OTHER_LETTERS.length)];
                    currentProbe = 'X';
                    break;
                case 'BY':
                    currentCue = OTHER_LETTERS[Math.floor(Math.random() * OTHER_LETTERS.length)];
                    currentProbe = OTHER_LETTERS[Math.floor(Math.random() * OTHER_LETTERS.length)];
                    break;
            }
        }
        
        function showFixation() {
            currentPhase = 'fixation';
            phaseIndicator.textContent = '';
            stimulus.textContent = '';
            stimulus.className = 'fixation';
            
            setTimeout(() => {
                if (taskRunning) showCue();
            }, FIXATION_TIME);
        }
        
        function showCue() {
            currentPhase = 'cue';
            phaseIndicator.textContent = '';
            stimulus.textContent = currentCue;
            stimulus.className = 'cue';
            
            setTimeout(() => {
                if (taskRunning) showDelay();
            }, CUE_TIME);
        }
        
        function showDelay() {
            currentPhase = 'delay';
            phaseIndicator.textContent = '';
            stimulus.textContent = '';
            stimulus.className = 'fixation';
            
            // Use variable delay time
            const variableDelayTime = getVariableTiming();
            setTimeout(() => {
                if (taskRunning) showProbe();
            }, variableDelayTime);
        }
        
        function showProbe() {
            currentPhase = 'probe';
            phaseIndicator.textContent = ``;
            stimulus.textContent = currentProbe;
            stimulus.className = 'probe';
            
            trialStartTime = performance.now();
            responseAllowed = true;
            
            // Set timeout for response
            trialTimeout = setTimeout(() => {
                if (responseAllowed) {
                    recordResponse(null);
                }
            }, RESPONSE_TIMEOUT);
        }
        
        function makeResponse(responseType) {
            if (!responseAllowed || !taskRunning) return;
            
            const reactionTime = performance.now() - trialStartTime;
            recordResponse(responseType, reactionTime);
        }
        
        function recordResponse(responseType, reactionTime = null) {
            responseAllowed = false;
            clearTimeout(trialTimeout);
            
            // Determine correct response
            const correctResponse = currentTrialType === 'AX' ? 'target' : 'non-target';
            const isCorrect = responseType === correctResponse;
            const responded = responseType !== null;
            
            const trialResult = {
                trial: currentTrial,
                trialType: currentTrialType,
                cue: currentCue,
                probe: currentProbe,
                correctResponse: correctResponse,
                actualResponse: responseType,
                reactionTime: reactionTime,
                correct: isCorrect,
                responded: responded
            };
            
            trialData.push(trialResult);
            
            // Show feedback
            phaseIndicator.textContent = '';
            if (!responded) {
                feedback.textContent = 'Too slow! Please respond faster.';
                feedback.className = 'feedback no-response';
            } else if (isCorrect) {
                feedback.textContent = 'Correct!';
                feedback.className = 'feedback correct';
            } else {
                feedback.textContent = `Incorrect. ${currentCue}→${currentProbe} should be ${correctResponse.toUpperCase()}`;
                feedback.className = 'feedback incorrect';
            }
            
            // ITI with variable timing
            setTimeout(() => {
                stimulus.textContent = '';
                stimulus.className = '';
                feedback.textContent = '';
                phaseIndicator.textContent = '';
                
                // Use variable ITI time
                const variableITITime = getVariableTiming();
                setTimeout(runTrial, variableITITime);
            }, FEEDBACK_TIME);
        }
        
        function endTask() {
            taskRunning = false;
            progress.textContent = 'Task completed!';
            phaseIndicator.textContent = '';
            feedback.textContent = '';
            startBtn.disabled = false;
            exportBtn.disabled = false;
            keyReminder.style.display = 'none';
            stimulus.textContent = 'Done!';
            calculateStats();
        }
        
        function calculateStats() {
            const axTrials = trialData.filter(t => t.trialType === 'AX');
            const ayTrials = trialData.filter(t => t.trialType === 'AY');
            const bxTrials = trialData.filter(t => t.trialType === 'BX');
            const byTrials = trialData.filter(t => t.trialType === 'BY');
            
            function getStats(trials, trialName) {
                const responded = trials.filter(t => t.responded);
                const correct = trials.filter(t => t.correct);
                const accuracy = trials.length > 0 ? (correct.length / trials.length) * 100 : 0;
                const meanRT = correct.length > 0 ? 
                    correct.reduce((sum, t) => sum + t.reactionTime, 0) / correct.length : 0;
                return { accuracy, meanRT, total: trials.length, name: trialName };
            }
            
            const axStats = getStats(axTrials, 'A→X (Target)');
            const ayStats = getStats(ayTrials, 'A→Y');
            const bxStats = getStats(bxTrials, 'B→X');
            const byStats = getStats(byTrials, 'B→Y');
            
            const overallAccuracy = (trialData.filter(t => t.correct).length / trialData.length) * 100;
            const respondedTrials = trialData.filter(t => t.responded);
            const overallRT = respondedTrials.length > 0 ? 
                respondedTrials.reduce((sum, t) => sum + t.reactionTime, 0) / respondedTrials.length : 0;
            
            statsContent.innerHTML = `
                <h4>Overall Performance:</h4>
                <ul>
                    <li><strong>Overall Accuracy:</strong> ${overallAccuracy.toFixed(1)}%</li>
                    <li><strong>Average Reaction Time:</strong> ${overallRT.toFixed(0)} ms</li>
                    <li><strong>Total Trials:</strong> ${trialData.length}</li>
                </ul>
                
                <h4>Performance by Trial Type:</h4>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    ${[axStats, ayStats, bxStats, byStats].map(stat => `
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 5px;">
                            <strong>${stat.name}:</strong><br>
                            Accuracy: ${stat.accuracy.toFixed(1)}% (${trialData.filter(t => t.trialType === stat.name.split('→')[0] + stat.name.split('→')[1].charAt(0)).filter(t => t.correct).length}/${stat.total})<br>
                            Mean RT: ${stat.meanRT.toFixed(0)} ms
                        </div>
                    `).join('')}
                </div>
            `;
            
            stats.style.display = 'block';
        }
        
        function exportData() {
            const csvContent = "data:text/csv;charset=utf-8," + 
                "Trial,TrialType,Cue,Probe,CorrectResponse,ActualResponse,ReactionTime,Correct,Responded\n" +
                trialData.map(row => 
                    `${row.trial},${row.trialType},${row.cue},${row.probe},${row.correctResponse},${row.actualResponse || 'null'},${row.reactionTime || 'null'},${row.correct},${row.responded}`
                ).join("\n");
            
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", `axcpt_data_${new Date().toISOString().slice(0,10)}.csv`);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        // Keyboard event listener
        document.addEventListener('keydown', function(event) {
            if (!responseAllowed || !taskRunning) return;
            
            if (event.key.toLowerCase() === 'j') {
                makeResponse('target');
            } else if (event.key.toLowerCase() === 'f') {
                makeResponse('non-target');
            }
        });
    </script>
</body>
</html>